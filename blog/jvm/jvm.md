---
title: 深入理解Java虚拟机-走进JVM
date: 2019-05-03 16:55:16
categories: jvm
tags: 笔记
---

# Java虚拟机体系结构

![](https://raw.githubusercontent.com/jinzzzzz/image/master/blog/jvm/jvm-st.png)

JVM由类加载器子系统，运行时数据区，执行引擎以及本地方法接口组成。

# 类加载器子系统

类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作被放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。

对于任意一个类，都需要由加载他的类加载器和这个类本身一同确定其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。

## 双亲委派模型

![](https://raw.githubusercontent.com/jinzzzzz/image/master/blog/jvm/jvm-class-loader.png)

从图中可以看出除了用户自定义的类加载器，系统中的类加载器可以分为三种类型：

- 启动类加载器（Bootstrap ClassLoader）：负责将存放在<JAVA_HOME>\lib目录中的或-Xbootclasspath参数指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到内存中。由C++语言实现。
- 扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。
- 应用程序类加载器（Application ClassLoader）。负责加载用户类路径（Classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况下这个就是程序中默认的类加载器。

各个类加载器之间的关系成为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当由自己的父类加载器加载，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派父类加载器去完成。每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个请求（他的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，应用程序会变得混乱。

**双亲委任模型的实现**

双亲委任模型的实现代码实现在java.lang.ClassLoader中的loadClass方法之中，代码如下：

```java
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 检查类是否已经加载
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    //父类抛出异常表示无法完成加载请求
                }

                if (c == null) { 
                    //调用自身的findClass()方法进行加载
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```

## 破坏双亲委任模型

双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载器实现方式。在Java的世界中大部分的类加载器都遵循者模型，但也有例外，到目前为止，双亲委派模型有过3次大规模的“被破坏”的情况。 

**第一次**：在双亲委派模型出现之前—–即JDK1.2发布之前。 

**第二次**：是这个模型自身的缺陷导致的。双亲委派模型很好的解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API， 但没有绝对，**如果基础类调用用户的代码**，例如JNDI服务，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI， Service Provider Interface）的代码，但启动类加载器不可能认识这些代码啊。因为这些类不在rt.jar中。

为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器。这个类加载器可以通过java.lang.Thread类的setContextClassLoader方法进行设置。如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过多的话，那这个类加载器默认即使应用程序类加载器。

有了线程上下文加载器，JNDI服务使用这个线程上下文加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。但这无可奈何，Java中所有涉及SPI的加载动作基本胜都采用这种方式。例如JNDI，JDBC，JCE，JAXB，JBI等。

**第三次**：为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换。

# 运行时数据区

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分成若干个不同的数据区域，这些数据区域都有各自的用途，以及创建和销毁时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》的规定，Java虚拟机管理的内存包括以下运行时数据区。

## 程序计数器

程序计数器是一块较小的内存空间，是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 

由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

## Java虚拟机栈

与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

局部变量表存放了编译期可知的八个基本数据类型、对象引用（reference类型），它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。

其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出OOM异常。

## 本地方法栈

本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。

## 堆

对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。堆是被所有线程共享的一块内存域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。

Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。

## 方法区

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。

Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OOM异常。

**运行时常量池**

运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。

 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。 

既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OOM异常。

## 直接内存

直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区域.但是这部分内存也被频繁的使用,而且也可能导致OutOfMemoryError异常出现。

在JDK1.4中新加入NIO类,引入了一种基于通道(Channel)与缓冲区(Buffer)的IO方式,它可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能,因为避免了在Java堆和Native对中来回复制数据。

显然,本机直接内存的分配不会受到Java堆大小的影响,但是既然是内存,肯定还是会受到本机总内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时,会根据实际内存设置-Xmx等参数信息,但是经常忽略直接内存,是的各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制),从而导致动态扩展时出现OutOfMemoryError异常。

# 执行引擎

在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，甚至可能会包含几个不同级别的编译器执行引擎。但从外观上看起来，所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

## 运行时栈帧结构

栈帧（stack frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

一个线程中的方法调用链可能会很长，很多方法都同时处理执行状态。对于执行引擎来讲，活动线程中，只有虚拟机栈顶的栈帧才是有效的，称为当前栈帧(Current Stack Frame)，这个栈帧所关联的方法称为当前方法(Current Method)。执行引用所运行的所有字节码指令都只针对当前栈帧进行操作。栈帧的概念结构如下图所示：

![](https://raw.githubusercontent.com/jinzzzzz/image/master/blog/jvm/jvm-stack.png)

接下来详细讲解下栈帧中的局部变量表、操作数栈、动态链接、方法返回地址等各个部分的作用和数据结构。

### 局部变量表

​	局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。
​	在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行实例方法，那局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。

​	为了尽可能节省栈帧空间，局部变量表中的Slot是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。不过，这样的设计会影响到系统的垃圾收集行为，请看以下代码演示：

```java
public static void main（String[]args）（）{
	byte[]placeholder=new byte[64*1024*1024]；
	System.gc（）；
}
```

​	上面的代码很简单，即向内存填充了64MB的数据，然后通知虚拟机进行垃圾收集。

​	我们可以在虚拟机运行参数中加上`-verbose：gc`来看看垃圾收集的过程，发现在System.gc()运行后并没有回收这个变量的内存，下面是运行的结果：

```tex
[GC 66846K-＞65824K（125632K），0.0032678 secs]
[Full GC 65824K-＞65746K（125632K），0.0064131 secs]
```

​	其实没有回收placeholder所占的内存能说得过去，因为在执行System.gc()时，变量placeholder还处于作用域之内，虚拟机自然不敢回收placeholder的内存。那我们把代码修改一下。

```java
public static void main（String[]args）（）{
    {
		byte[]placeholder=new byte[64*1024*1024]；
    }
	System.gc（）；
}
```

​	加入了花括号之后，placeholder的作用域被限制在花括号之内，从代码逻辑上讲，在执行System.gc()的时候，placeholder已经不可能再被访问了，但执行一下这段程序，会发现运行结果如下，还是有64MB的内存没有被回收，这又是为什么呢？

```tex
[GC 66846K-＞65888K（125632K），0.0009397 secs]
[Full GC 65888K-＞65746K（125632K），0.0051574 secs]
```

​	在解释为什么之前，我们先对这段代码进行在进行一次修改，在调用System.gc()之前加入一行“int a = 0；”，

```java
public static void main（String[]args）（）{
    {
		byte[]placeholder=new byte[64*1024*1024]；
    }
    int a = 0；
	System.gc（）；
}
```

​	这个修改看起来很莫名其妙，但运行一下程序，却发现这次内存真的被正确回收了。

```tex
[GC 66401K-＞65778K（125632K），0.0035471 secs]
[Full GC 65778K-＞218K（125632K），0.0140596 secs]
```

​	在以上的代码演示中，placeholder能否被回收的根本原因是：局部变量表中的Slot是否还存有关于placeholder数组对象的引用。第一次修改中，代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder原本所占用的Slot还没有被其他变量所复用，所以作为GC Roots一部分的局部变量表仍然保持着对它的关联。

​	这种关联没有被及时打断，在绝大部分情况下影响都很轻微。但如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值（用来代替那句inta=0，把变量对应的局部变量表Slot清空）便不见得是一个绝对无意义的操作，这种操作可以作为一种在极特殊的情形下使用。

​	关于局部变量表，还有一点，就是局部变量不像类变量那样存在“准备阶段”。我们知道类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的值。因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的。

### 操作数栈

​	操作数栈也常被称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也是编译的时候被写入到方法表的Code属性的max_stacks数据项中。

​	当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。

​	举个例子，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈。

​	Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。

### 动态连接

​	每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。

### 方法返回地址

​	当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口。

​	另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。

​	无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。

​	方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用都栈帧的操作数栈中，调用PC计数器的值以指向方法调用指令后面的一条指令等。

## 方法调用

方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于直接引用）。

这个特性给Java带来了更强大的动态扩展能力，但也使Java方法调用过程变得相对复杂起来，需要在类加载期间甚至到运行期间才能确定目标方法的直接引用。

### 解析

​	方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析（Resolution）。

​	在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。

​	静态方法、私有方法、实例构造器、父类方法4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法可以称为非虚方法，与之相反，其他方法称为虚方法（除去final方法）。

​	Java中的非虚方法还有一种，就是被final修饰的方法。虽然final方法是使用invokevirtual指令来调用的，但是由于它无法被覆盖，没有其他版本，所以也无须对方法接收者进行多态选择，又或者说多态选择的结果肯定是唯一的。在Java语言规范中明确说明了final方法是一种非虚方法。

### 分派

​	Java具备面向对象的3个基本特征：封装、继承和多态。接下来的分配调用过程就会揭示重载和重写在Java虚拟机中是如何实现的，虚拟机是如何确定正确的目标方法的。

#### 1.静态分派

​	静态分派代码演示：

```java
public class StaticDispatch {
	static abstract class Human{
	}
	static class Man extends Human{
	}
	static class Woman extends Human{
	}
	
	public void sayHello(Human guy){
		System.out.println("hello guy");
	}
	public void sayHello(Man guy){
		System.out.println("hello gentleman");
	}
	public void sayHello(Woman guy){
		System.out.println("hello lady");
	}
	public static void main(String[] args) {
		Human man = new Man();
		Human woman = new Woman();
		StaticDispatch sr = new StaticDispatch();
		sr.sayHello(man);
		sr.sayHello(woman);
	}
}
```

​	运行结果：

```tex
hello guy
hello guy

```

​	这段代码考察了对重载的理解程度。

​	Human man= new Man();

​	我们把上面代码中的“Human”称为变量的静态类型，后面的“Man”则称为变量的实际类型，静态类型的变化仅仅在使用时发生，变量本身的静态类型不会改变，并且最终的静态类型是编译器可知的；实际类型变化的结果要在运行期才可确定，编译器在编译程序时并不知道一个对象的实际类型是什么。

​	在看上面代码中两次调用sayHello()方法，在方法接收者已经确定是对象“sr”的前提下，使用哪个重载版本，取决于传入参数的数量和数据类型。Main中定义了两个静态类型相同但实际类型不同的变量，虚拟机（准确说是编译器）在重载时是通过参数的静态类型而不是实际类型做判断依据的。因此，在编译阶段，Javac编译器根据参数的静态类型决定使用哪个重载版本，所以选择了sayHello(Human)作为调用目标，并把这个方法的符号引用写到main()方法里的两条invokevirtual指令参数中。

​	所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。

​	编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一”的，往往只能确定一个更加合适的版本。产生这种模糊结论的主要原因是字面量不需要定义，所以字面量没有显示的静态类型，它的静态类型只能通过语言上的规则去理解和推断。

#### 2.动态分派

​	动态分派的过程和重写（Overrider）有着密切的关联。下面来看动态分配的代码例子。

```java
public class StaticDispatch {
	static abstract class Human{
		public abstract void sayHello();
	}
	static class Man extends Human{
		@Override
		public void sayHello(){
			System.out.println("Man hello guy");
		}		
	}
	static class Woman extends Human{
		@Override
		public void sayHello(){
			System.out.println("Woman hello guy");
		}			
	}
	
	public static void main(String[] args) {
		Human man = new Man();
		Human woman = new Woman();
		man.sayHello();
		woman.sayHello();
		
		man = new Woman();
		man.sayHello();
	}	
}

```

​	运行结果：

```tex
Man hello guy
Woman hello guy
Woman hello guy

```

​	这个结果不难预料，但虚拟机是如何知道要调用那个方法的呢？

​	显然这里不可能再根据静态类型来决定，因为静态类型同样都是Human的两个变量man和woman在调用sayHello()方法时执行了不同的行为，并且变量man在两次调用中执行了不同的方法。导致这个现象的原因很明显，是这两个变量的实际类型不同，Java虚拟机是如何根据实际类型来分派方法执行版本的呢？

​	这就需要从invokevirtual指令的多态查找过程开始说起，invokevirtual指令的运行时解析过程大致分为以下几个步骤：

​	1）找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。

​	2）如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找结束；如果不通过，则返回java.lang.IllegalAccessError异常。

​	3）否则，按继承关系从下往上一次对C的个父类进行第2步的搜索和验证过程。

​	4）如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。

​	由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程是java语言中方法重写的本质。这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。

#### 3.单分派与多分派

​	单分派和多分派取决于宗量,  方法的接受者与方法的参数统称为方法的宗量，根据一个宗量对目标方法进行选择就是单分派，多于一个宗量对目标方法进行选择就是多分派。

​	以下代码作为单分派和多分派的例子

```java
public class Dispatch {
 
	static class QQ {}
 
	static class _360 {}
 
	public static class Father {
		public void hardChoice(QQ arg) {
			System.out.println("father choose qq");
		}
 
		public void hardChoice(_360 arg) {
			System.out.println("father choose 360");
		}
	}
 
	public static class Son extends Father {
		public void hardChoice(QQ arg) {
			System.out.println("son choose qq");
		}
 
		public void hardChoice(_360 arg) {
			System.out.println("son choose 360");
		}
	}
 
	public static void main(String[] args) {
		Father father = new Father();
		Father son = new Son();
		father.hardChoice(new _360());
		son.hardChoice(new QQ());
	}
}

```

​	运行结果：

```tex
father choose 360
son choose qq

```

​	在静态分派的过程中，选择目标方法的依据有两点：一是看对象的静态类型时什么，即是 Father 还是 Son。 二是方法参数的类型和数量是 QQ还是 360 。因为是根据两个宗量进行选择，所以 Java 语言的静态分派属于多分派类型。

​	在动态分派的过程中，由于编译器已经决定了目标方法的签名，因此只需要找到方法的接受者就可以了。因为是根据一个宗量进行选择，所以 Java 语言的动态分派属单分派类型。

#### 4.动态分派的实现

​	由于动态分配是非常频繁的动作，而且动态分配的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真正的进行如此频繁的搜索。最常用的手段就是为类在方法区中建立一个虚方法表（Virtual Method Table , 也称为 vtable ，在 invokeinterface 执行时也会用到接口方法表-Inteface Method Table ， 简称 itable），使用虚方法表索引来代替元数据查找以提高性能。虚方法表结构示例如图：

![](https://raw.githubusercontent.com/jinzzzzz/image/master/blog/jvm/jvm-vtable.png)

虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口。如上图，Son 重写了来自于 Father 的全部方法，因此 Son 的方法表没有指向 Father 类型数据的箭头。但是 Son 和 Father 都没有重写来自于 Object 的方法，所以他们的方法表中所有从 Object 继承来的方法都指向了 Object 的数据类型。

方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值之后，虚拟机会把该类的方法表也初始化完毕。

# 对象

Java是一门面向对象的编程语言,在Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上,创建对象(例如克隆、反序列化)通常仅仅是一个new关键字而已,而在虚拟机中,对象(这里讨论的对象限于普通Java对象,不包括数组和Class对象等)的创建又是怎样一个过程？对象在内存中又是如何存储的？我们是怎么定位到对象的?接下来就揭晓这几个问题的答案。

## 对象创建

虚拟机遇到一条new指令时 ,首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用,并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

在类加载检查通过后,接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定,为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。

假设Java堆中内存是绝对规整的,所有用过的内存都放在一边,空闲的内存放在另一边,中间放着一个指针作为分界点的指示器,那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离,这种分配方式称为指针碰撞( Bump the Pointer ) 。

![](https://raw.githubusercontent.com/jinzzzzz/image/master/blog/jvm/jvm-bump.png)

如果Java堆中的内存并不是规整的,已使用的内存和空闲的内存相互交错,那就没有办法简单地进行指针碰撞了,虚拟机就必须维护一个列表,记录上哪些内存块是可用的,在分配的时候从列表中找到一块足够大的空间划分给对象实例, 并更新列表上的记录,这种分配方式称为空闲列表( Free List)。

![](https://raw.githubusercontent.com/jinzzzzz/image/master/blog/jvm/jvm-free_list.png)

选择哪种分配方式由Java堆是否规整决定,而堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时,通常采用空闲列表。

除如何划分可用空间之外,还有一个需要考虑的问题是在并发情况下对象的创建并不是线程安全的, 可能出现正在给对象A分配内存,指针还没来得及修改,对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案,一种是对分配内存空间的动作进行同步处理，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间之中进行,即每个线程在堆中预先分配一小块内存 ,称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB ) 。哪个线程要分配内存 ,就在哪个线程的TLAB上分配,只有TLAB用完并分配新的TLAB时 ,才需要同步锁定。 虚拟机是否使用TLAB,可以通过-XX : +/-UseTLAB参数来设定。

内存分配完成后,虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头), 如果使用TLAB ,这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用,程序能访问到这些字段的数据类型所对应的零值。

接下来 ,虚拟机要对对象进行必要的设置,例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头(Object Header ) 之中。根据虚拟机当前的运行状态的不同,如是否启用偏向锁等,对象头会有不同的设置方式。关于对象头的具体内容,稍后再做详细介绍。

在上面工作都完成之后,从虚拟机的视角来看,一个新的对象已经产生了,但从Java程序的视角来看,init方法还没有执行,所有的字段都还为零。 所以一般来说(由字节码中是否跟随invokespecial指令所决定),执行new指令之后会接着执行init方法,把对象按照程序员的意愿进行初始化,这样一个真正可用的对象才算完全产生出来。

对象创建流程图示：

![](https://raw.githubusercontent.com/jinzzzzz/image/master/blog/jvm/jvm-create_object.png)

## 内存布局

在HotSpot虚拟机中,对象在内存中存储的布局可以分为3块区域:对象头( Header )、实例数据( Instance Data ) 和对齐填充( Padding )。

### 对象头

HotSpot虚拟机的对象头包括两部分信息。第一部分用于存储对象自身的运行时数据, 如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等 ,官方称它为“Mark Word”。对象需要存储的运行时数据很多,考虑到虚拟机的空间效率, Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息,它会根据对象的状态复用自己的存储空间。

在32位的HotSpot虚拟机中,如果对象处于未被锁定的状态下,那么Mark Word的32bit空间中的25bit用于存储对象哈希码,4bit用于存储对象分代年龄,2bit用于存储锁标志位,1bit固定为0 ,而在其他状态(轻量级锁定、重量级锁定、GC标记、可偏向)下对象的存储内容见下表：

| 存储内容                           | 标志位 | 状态     |
| ---------------------------------- | ------ | -------- |
| 哈希码、GC分代年龄                 | 01     | 无锁     |
| 指向锁记录的指针                   | 00     | 轻量级锁 |
| 指向重量级锁的指针                 | 10     | 重量级锁 |
| 空                                 | 11     | GG标记   |
| 偏向线程ID、偏向时间戳、GC分代年龄 | 01     | 偏向锁   |

图示：

![](https://raw.githubusercontent.com/jinzzzzz/image/master/blog/jvm/jvm-mark_word.png)

对象头的另外一部分是类型指针,即对象指向它的类元数据的指针,虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针,换句话说,查找对象的元数据信息并不一定要经过对象本身。另外 ,如果对象是一个Java数组 ,那在对象头中还必须有一块用于记录数组长度的数据。

### 实例数据

实例数据部分是对象真正存储的有效信息,也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的,还是在子类中定义的,都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、 oops ( Ordinary Object Pointers ) , 从分配策略中可以看出,相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下,在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true ( 默认为true ) ,那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。

### 对齐填充

对齐填充并不是必然存在的,也没有特别的含义,它仅仅起着占位符的作用。 由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍,换句话说, 就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数(1倍或者2倍 ), 因此 ,当对象实例数据部分没有对齐时,就需要通过对齐填充来补全。

## 访问定位

建立对象是为了使用对象,我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用,并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置,所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。

如果使用句柄访问的话,那么Java堆中将会划分出一块内存来作为句池,reference中存储的就是对象的句柄地址,而句柄中包含了对象实例数据与类型数据各自的具体地址信息 ,如下图所示：

![](https://raw.githubusercontent.com/jinzzzzz/image/master/blog/jvm/jvm-handle.png)

如果使用直接指针访问,那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息,而reference中存储的直接就是对象地址,如下图所示：

![](https://raw.githubusercontent.com/jinzzzzz/image/master/blog/jvm/jvm-direct.png)

这两种对象访问方式各有优势,使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址,在对象被移动时只会改变句柄中的实例数据指针,而reference本身不需要修改。垃圾收集时移动对象是非常普遍的行为。

使用直接指针访问方式的最大好处就是速度更快,它节省了一次指针定位的时间开销, 由于对象的访问在Java中非常频繁,因此这类开销积少成多后也是一项非常可观的执行成本。对于虚拟机HotSpot而言,它是使用第二种方式进行对象访问的,但各种语言和框架使用句柄来访问的情况也十分常见。

# 类加载机制

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

与那些在编译时需要进行连接的语言不同，Java可以动态扩展的特性依赖于运行期动态加载和动态连接，这种策略虽然会令类加载时稍微增加一些性能开销，但是这样为Java应用程序提供了高度的灵活性。我们编写的一个接口，可以等到运行时再指定其实际的实现类。我们甚至可以从网络或者其他的地方加载一个二进制流作为程序的一部分。

## 类加载时机

类从被加载到虚拟机内存中开始到卸载为止，它的整个生命周期包括：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中验证、准备、解析3个部分统称为连接(Linking)，这7个阶段的发生顺序如图：

![](https://raw.githubusercontent.com/jinzzzzz/image/master/blog/jvm/jvm-loading.png)

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。

什么情况下需要开始类加载过程的第一个阶段：加载？Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：

1. 遇到`new`、`getstatic`、`putstatic`或`invokestatic`这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是
   - 使用new关键字实例化对象的时候
   - 读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候
   - 调用一个类的静态方法的时候。
2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化则需要先触发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main方法的那个类)，虚拟机会先初始化这个主类。
5. 当使用JDK 1.7的动态语言支持时，一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

对于这5种会触发类进行初始化的场景，虚拟机规范中称为”有且只有“，这5中场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。下面举几个被动引用的代码例子。

创建一个父类和一个子类：

```java
public class SuperClass {
    static {
        System.out.println("SuperClass（父类）被初始化了。。。");
    }
    public static int value = 233;
}

```

```java
public class Subclass extends SuperClass {
    static {
        System.out.println("Subclass（子类）被初始化了。。。");
    } 
}

```

通过子类调用父类静态变量：

```java
public class Test {
    public static void main(String[] args) {
        System.out.println(Subclass.value);
    }
}

```

输出结果：

```tex
SuperClass（父类）被初始化了。。。
233

```

可以看到代码运行后只初始化了静态变量所在的类，因此通过子类调用父类中定义的静态变量，只会触发父类的初始化而不会触发子类的初始化。

通过数组定义引用类：

```java
public class Test {
    public static void main(String[] args) {
        SuperClass[] superClasses = new SuperClass[3];
    }
}

```

这段代码运行后没有任何输出，说明没有触发类SuperClass的初始化阶段。

创建一个类，定义常量：

```java
public class ConstClass {
    static {
        System.out.println("ConstClass被初始化了。。。");
    }
    public static final String HELLO = "hello world";
}

```

```java
public class Test {
    public static void main(String[] args) {
        System.out.println(ConstClass.HELLO);
    }
}

```

调用ConstClass类的常量，输出结果：

```tex
hello world

```

发现代码运行后，并没有输出ConstClass类的初始化信息，这是因为虽然引用了ConstClass类的常量HELLO，但其实在编译阶段通过常量传播优化，已经将此常量的值`hello world`存储到了Test类中的常量池中，之后Test类中对于常量ConstClass.HELLO的引用实际都被转化为Test类对自身常量池的引用了。

## 类加载过程

接下来我们详细讲解一下虚拟机中类加载的全过程，也就是加载、验证、准备、解析和初始化这5个阶段所执行的具体动作。

### 加载

“加载” 是 “类加载”过程的一个阶段，在加载阶段，虚拟机需要完成以下3件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口。

虚拟机规范的这3点要求其实并不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的。例如第一条通过类的全限定名来获取定义此类的二进制字节流，它没有指明二进制字节流要从哪里获取和怎样获取。因此，许多Java技术都建立在这一基础之上，例如：

- 从zip包中读取，成为JAR、EAR、WAR格式的基础。
- 从网络中获取，这种场景最典型的应用就是Applet。
- 运行时计算生成，这种场景最常用的就是动态代理技术了。
- 由其他文件生成，例如JSP生成对应的Class类。
- 从数据库中读取，这种场景相对比较少见。

相对于类加载过程的其他阶段，通过类的全限定名来获取定义此类的二进制字节流是开发人员可控性最强的动作，因为加载阶段既可以使用系统提供的类加载器来完成，也可以由用户自定义的类加载器去完成。开发人员可以重写一个类加载器的loadClass()方法，去控制字节流的获取方式。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中。然后在内存中实例化一个这个类的Class对象，这个对象作为程序访问方法区的这些类型数据的外部接口。

加载阶段与连接阶段的部分内容是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。

### 验证

验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

虚拟机如果不检查输入的字节流，并对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。这个阶段的严谨直接决定了java虚拟机是否能承受恶意代码的攻击。

验证阶段大致上会完成4个阶段的校验工作：文件格式验证、元数据验证、字节码验证、符号引用验证。

1. 文件格式验证

   验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。

   例如验证是否以魔数0xCAFEBABE开头、JDK版本号是否在当前虚拟机处理范围之内等等。

   该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。这个阶段验证是基于二进制字节流进行的，只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面的3个阶段的全部是基于方法区的存储结构进行的，不会再直接操作字节流。

2. 元数据验证

   该阶段对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，目的是保证不存在不符合Java语言规范的元数据信息。

   例如验证这个类是否有父类、是否继承了不允许被继承的类等等。

3. 字节码验证

   该阶段目的是通过数据流和控制流分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。 

   例如保证跳转指令不会跳转到方法体以外的字节码指令上、保证方法体中的类型转换是有效的等等。

   如果一个方法体通过了字节码验证，也不能说明其一定是安全的，因为校验程序逻辑无法做到绝对精确。

4. 符号引用验证

   最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的解析阶段中发生。符号引用验证的目的是确保解析动作能正常执行。

   例如验证符号引用通过全限定名是否能找到对应的类、验证在指定类中是否存在符合方法的字段描述符等等。

### 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

初始值通常是数据类型的零值：

例如public static int value = 123；那么变量value在准备阶段过后的初始值为0而不是123，这时候尚未开始执行任何java方法，把value赋值为123的动作将在初始化阶段才会被执行。

而对于：public static final int value = 123；编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。

下表为基本数据类型的零值

| 数据类型 | 零值     | 数据类型  | 零值  |
| -------- | -------- | --------- | ----- |
| int      | 0        | boolean   | false |
| long     | 0L       | float     | 0.0f  |
| short    | (short)0 | double    | 0.0d  |
| char     | '\u0000' | reference | null  |
| byte     | (byte)0  |           |       |

### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

**那么符号引用与直接引用有什么关联呢？**

- 符号引用(Symbolic References)：符号引用以一组符号来描述所引用的目标，符号可以是符合约定的任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。
- 直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用与虚拟机实现的内存布局相关，引用的目标必定已经在内存中存在。

虚拟机规范没有规定解析阶段发生的具体时间，虚拟机实现可以根据需要来判断到底是在类被加载时解析还是等到一个符号引用将要被使用前才去解析。

同一符号引用进行多次解析请求是很常见的，除invokedynamic指令以外，虚拟机实现可以对第一次解析结果进行缓存，来避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个引用符号之前已经被成功解析过，那么后续的引用解析请求就应当一直成功；同样的，如果 第一次解析失败，那么其他指令对这个符号的解析请求也应该收到相同的异常。

### 初始化

类初始化阶段是类加载的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码。

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据开发人员开发的初始化方法进行初始化，也就是执行类的初始化代码块。